{"name":"Ruby marks","tagline":"Ruby Marks","body":"Ruby Marks \r\n==========\r\n\r\n[![Build Status](https://secure.travis-ci.org/andrerpbts/ruby_marks.png?branch=master)](http://travis-ci.org/andrerpbts/ruby_marks)\r\n[![Code Climate](https://codeclimate.com/github/andrerpbts/ruby_marks/badges/gpa.svg)](https://codeclimate.com/github/andrerpbts/ruby_marks)\r\n[![Test Coverage](https://codeclimate.com/github/andrerpbts/ruby_marks/badges/coverage.svg)](https://codeclimate.com/github/andrerpbts/ruby_marks)\r\n\r\nA simple OMR ([Optical Mark Recognition](http://en.wikipedia.org/wiki/Optical_mark_recognition)) gem for ruby.\r\n\r\n\r\nRequirements\r\n------------\r\n\r\nThis gem uses [ImageMagick](http://www.imagemagick.org) to manipulate the given images.\r\nYou can verify if this utility is installed by the command line `which convert`, which should return \r\nthe current ImageMagick path.\r\n\r\nFor example, `/usr/local/bin/convert`.\r\n\r\nIf not installed:\r\n\r\n### MacOS X\r\n\r\nIf you're on Mac OS X, Homebrew may be your best option:\r\n\r\n    brew install imagemagick\r\n\r\n\r\n### Ubuntu\r\n\r\nOn Ubuntu, the `apt-get` should be enough:\r\n    \r\n    apt-get install imagemagick\r\n\r\n\r\nSupported versions\r\n------------------\r\n\r\n* Ruby 1.9.3\r\n* Ruby 2.0.x\r\n* Ruby 2.1.x\r\n\r\nInstall\r\n-------\r\n\r\nIf you are using `Bundler`, just put this line in your Gemfile:\r\n\r\n```ruby\r\ngem 'ruby_marks'\r\n```\r\n\r\nThen run bundle install command:\r\n    \r\n    bundle\r\n\r\nIf not, you still can run a default gem installation method:\r\n    \r\n    gem install ruby_marks\r\n\r\nAnd require it in your ruby code:\r\n\r\n```ruby\r\nrequire 'ruby_marks' \r\n```\r\n\r\n\r\nHow it Works\r\n------------\r\n\r\nUsing a template document, you should especify the expected area where each group is. By applying an edge detect algorithm\r\nit will discover where the groups are, and will check if they are near the expected position. \r\nAfter the groups being found, the gem will perform a scan in each group in order to recognize their marks. \r\nIn the end, returns a hash with each correspondent mark found in the group.\r\n\r\nThe gem will not perform deskew in your documents. If the document have a huge skew, then you should apply your own\r\ndeskew method on the file before.\r\n\r\n```\r\nNOTE:\r\nWe changed the way it recognizes the marks. It's not based on clocks anymore. If you are updating the gem \r\nfrom 0.1.4 version, you should refactor your code to eliminate the clocks parameters and adjust \r\nsome new configurations.\r\n```\r\n\r\nUsage\r\n-----\r\n\r\nUnfortunatelly, this gem will require a bit more configuration to work, since the implementation depends \r\na lot of your document sizes, positions, brightness, etc...\r\n\r\nThat said, lets describe it's basic structure. The example will assume a directory with some png images like this one:\r\n\r\n[![Document Example](https://raw.github.com/andrerpbts/ruby_marks/master/assets/sheet_demo2.png)](https://github.com/andrerpbts/ruby_marks/blob/master/assets/sheet_demo2.png)\r\n\r\n\r\nFirst, we will need to get the pixels coordinates, using one document as template, of the areas \r\nwhere the expected groups are. This image can explain where to pick each position:\r\n\r\n[![Document Example](https://raw.github.com/andrerpbts/ruby_marks/master/assets/sheet_demo2_group_coords.png)](https://github.com/andrerpbts/ruby_marks/blob/master/assets/sheet_demo2_group_coords.png)\r\n\r\n\r\nThe threshold level should be adjusted too, in order to don't get a too bright or too polluted marks. See:\r\n\r\n[![Document Example](https://raw.github.com/andrerpbts/ruby_marks/master/assets/threshold_examples.png)](https://github.com/andrerpbts/ruby_marks/blob/master/assets/threshold_examples.png)\r\n\r\n\r\nThen, we write a basic code to scan it and print result on console (each option available are described bellow):\r\n\r\n```ruby\r\n# Instantiate the Recognizer \r\nrecognizer = RubyMarks::Recognizer.new\r\n\r\n# Configuring the document aspects\r\nrecognizer.configure do |config|\r\n  config.threshold_level = 90\r\n  config.default_expected_lines = 5\r\n\r\n  config.define_group :first  do |group|\r\n    group.expected_coordinates = {x1: 34, y1: 6, x2: 160, y2: 134}\r\n  end\r\n\r\n  config.define_group :second do |group| \r\n    group.expected_coordinates = {x1: 258, y1: 6, x2: 388, y2: 134}\r\n  end\r\n\r\n  config.define_group :third  do |group| \r\n    group.expected_coordinates = {x1: 486, y1: 6, x2: 614, y2: 134}\r\n  end\r\n\r\n  config.define_group :fourth do |group| \r\n    group.expected_coordinates = {x1: 714, y1: 6, x2: 844, y2: 134}\r\n  end\r\n\r\n  config.define_group :fifth  do |group| \r\n    group.expected_coordinates = {x1: 942, y1: 6, x2: 1068, y2: 134}\r\n  end\r\nend\r\n```\r\n\r\n\r\nThen we need to adjust the edge level to make sure the groups are being highlighted enough to being recognized. \r\nYou can see the image after the edge algorithm is applied if you write the file after submit it to Recognizer. Like this:\r\n\r\n```ruby\r\nrecognizer.file = 'example.png'\r\nfile = @recognizer.file\r\nfilename = \"temp_image.png\"\r\nfile.write(filename)\r\n```\r\n\r\nThe result image should be like this one (note that all the groups are separated from the rest of the document these white blocks):\r\n\r\n[![Document Example](https://raw.github.com/andrerpbts/ruby_marks/master/assets/sheet_demo2_edge.png)](https://github.com/andrerpbts/ruby_marks/blob/master/assets/sheet_demo2_edge.png)\r\n\r\n\r\nThere's a method you can call to help you to identify how the document is being recognized. This method return the image\r\nwith the showing where is the expected groups coordinates are, where are the actual groups coordinates, and where the marks \r\nis being recognized in each group.\r\n\r\nExample:\r\n\r\n```ruby\r\nflagged_document = recognizer.flag_all_marks\r\nflagged_document.write(temp_filename)\r\n```  \r\n\r\nWill return the image below:\r\n\r\n[![Flagged Document Example](https://raw.github.com/andrerpbts/ruby_marks/master/assets/sheet_demo2_flagged.png)](https://github.com/andrerpbts/ruby_marks/blob/master/assets/sheet_demo2_flagged.png)\r\n\r\n\r\nWith all this configured, we can submit our images to a scan:\r\n\r\n```ruby\r\n# Read all documents in directory thats in a png format\r\nDir[\"./*.png\"].each do |file|\r\n  recognizer.file = file\r\n  puts recognizer.scan\r\nend\r\n```\r\n\r\nAnd, this should puts each scan in a hash, like this:\r\n\r\n```\r\n{\r\n  first: { \r\n    1 => ['A'],\r\n    2 => ['C'],\r\n    3 => ['B'],\r\n    4 => ['B'],\r\n    5 => ['D']\r\n  },\r\n  second: {\r\n    1 => ['E'],\r\n    2 => ['A'],\r\n    3 => ['B'],\r\n    4 => ['A'],\r\n    5 => ['B']\r\n  },\r\n  three: {\r\n    1 => ['B'],    \r\n    2 => ['B'],\r\n    3 => ['D'], \r\n    4 => ['B'],    \r\n    5 => ['B']\r\n  },\r\n  four: {\r\n    1 => ['B'],\r\n    2 => ['E'],    \r\n    3 => ['A'],    \r\n    4 => ['C'],    \r\n    5 => ['D']\r\n  },\r\n  five: {\r\n    1 => ['B'],\r\n    2 => ['A'],\r\n    3 => ['A'],\r\n    4 => ['C'],\r\n    5 => ['D']\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\nGeneral Configuration Options\r\n-----------------------------\r\n\r\nAs you may see, it's necessary configure some document aspects to make this work properly. So, lets describe\r\neach general configuration option available:\r\n\r\n### Edge level\r\n\r\n```ruby\r\n# The size of the edge to apply in the edge detect algorithm. \r\n# The default value is 4, but is very important you verify the algorithm result and adjust it to work.\r\nconfig.edge_level = 4\r\n```\r\n\r\n### Threshold level \r\n\r\n```ruby\r\n# Applies the given percentual in the image in order to get it back with only black and white pixels. \r\n# Low percentuals will result in a bright image, as High percentuals will result in a more darken image.\r\n# The default value is 60, but is very important you verify the algorithm result and adjust it to work.\r\n\r\nconfig.threshold_level = 60  \r\n```\r\n\r\n### Scan timeout \r\n\r\n```ruby\r\n# Sets a timeout in seconds, to break long time scans.   \r\n# The default value is 0 (zero) and means there's no timeout. Any value will quit the scan and raise timed_out_watcher\r\n\r\nconfig.scan_timeout = 0  \r\n```\r\n\r\n### Expected lines\r\n\r\n```ruby\r\n# The scan will raise the incorrect group watcher if one or more group don't have the expected number of lines\r\n# Here, this configuration becomes valid to all groups.\r\n# The default value is 20, but is very \r\n\r\nconfig.default_expected_lines = 20\r\n```\r\n\r\n\r\n### Default blocks sizes tolerances\r\n\r\n```ruby\r\n# Defines the tolerance in width and height of the group blocks (in pixels) to compare with de expected block size.\r\n# This tolerance is intended to make the scan recognizes the correct whole group. The scanned area + this tolerance \r\n# should be greater than the expected sizes of the block, in order to consider it. \r\n# In small size groups, you should reduce this parameter in order to don't capture weong groups positions, such a \r\n# not marked bubble as a group, for example.\r\n# The default values is 100 for both width and height, and should be adjusted for your documents. \r\n\r\nconfig.default_block_width_tolerance = 100\r\nconfig.default_block_height_tolerance = 100\r\n```\r\n\r\n\r\n### Default mark sizes\r\n\r\n```ruby\r\n# Defines the expected width and height of the marks (in pixels). With the tolerance, if the recognized \r\n# mark exceeds or stricts those values, it will be ignored.\r\n# The default values is 20 to width and 20 to height. Since the marks can be different, you SHOULD\r\n# calculate those sizes for your documents. \r\n\r\nconfig.default_mark_width = 20\r\nconfig.default_mark_height = 20\r\n```\r\n\r\n### Default mark sizes tolerances\r\n\r\n```ruby\r\n# Defines the tolerance in width and height of the marks (in pixels). With default_mark_width and default_mark_width\r\n# size, if the recognized mark exceeds or stricts those values, it will be ignored.\r\n# The default values is 4 for both width and height. \r\n\r\nconfig.default_mark_width_tolerance = 4\r\nconfig.default_mark_height_tolerance = 4\r\n```\r\n\r\n### Intensity percentual\r\n\r\n```ruby\r\n# Set the intensity sensitivity (in percentual) expected to recognize a mark as a marked one. \r\n# When the scan find some potential marked area, then it will analyse if the count of valid pixels (black pixels)\r\n# have this minimun percentage.\r\n# Increasing this value, the recognition becomes more sensitive and can ignore valid weaker markings. \r\n# Decreasing this value, recognition becomes less sensitive and can recognize false markings.\r\n# The default value is 50. \r\n\r\nconfig.intensity_percentual = 50\r\n```\r\n\r\n### Default marks options\r\n\r\n```ruby\r\n# Set the marks options that the groups represents. When the scan recognizes a mark in some position,\r\n# it will return they value in the result hash.\r\n# The default value is the [A, B, C, D, E] array.\r\n\r\nconfig.default_marks_options = %w{A B C D E}\r\n```\r\n\r\n### Default distance between each mark in group\r\n\r\n```ruby\r\n# Defines the distance (in pixel) between the middle of a mark and the middle of the next mark in the same group.\r\n# This option is used to try suppose not found marks.\r\n# The default value is 25\r\n\r\nconfig.default_distance_between_marks = 25\r\n```\r\n\r\n\r\nGroup Configuration Options\r\n---------------------------\r\n\r\nThe General Configuration Options is more generic for the entire document. So, you can have some particularities\r\nwhen defining a group. So:\r\n\r\n### Expected coordinates\r\n\r\n```ruby\r\n# This configuration defines the area coordinate where the group is expected to be. \r\n\r\ngroup.expected_coordinates = {x1: 145, y1: 780, x2: 270, y2: 1290}\r\n```\r\n\r\n### Block sizes tolerances\r\n\r\n```ruby\r\n# It overwrites the default_block_width_tolerance and default_block_height_tolerance values for the group you configure it. \r\n\r\ngroup.block_width_tolerance  = RubyMarks.default_block_width_tolerance\r\ngroup.block_height_tolerance = RubyMarks.default_block_height_tolerance\r\n```\r\n\r\n### Mark sizes\r\n\r\n```ruby\r\n# It overwrites the default_mark_width and default_mark_height values for the group you configure it. \r\n\r\ngroup.mark_width  = RubyMarks.default_mark_width\r\ngroup.mark_height = RubyMarks.default_mark_height\r\n```\r\n\r\n### Mark sizes tolerances\r\n\r\n```ruby\r\n# It overwrites the default_mark_width_tolerance and default_mark_height_tolerance values for the group you configure it. \r\n\r\ngroup.mark_width_tolerance  = RubyMarks.default_mark_width_tolerance\r\ngroup.mark_height_tolerance = RubyMarks.default_mark_height_tolerance\r\n```\r\n\r\n### Marks options\r\n\r\n```ruby\r\n# It overwrites the default_marks_options values for the group you configure it. \r\n\r\ngroup.marks_options = RubyMarks.default_marks_options\r\n```\r\n\r\n### Distance Between Marks\r\n\r\n```ruby\r\n# It overwrites the default_distance_between_marks values for the group you configure it. \r\n\r\ngroup.distance_between_marks = RubyMarks.default_distance_between_marks\r\n```\r\n\r\n### Expected lines\r\n\r\n```ruby\r\n# It overwrites the default_expected_lines values for the group you configure it. \r\n\r\ngroup.expected_lines = @recognizer.config.default_expected_lines\r\n```\r\n\r\n\r\nWatchers\r\n--------\r\n\r\nSometimes, due some image flaws, the scan can't recognize some group, or a mark, or even recognize \r\nmore than one mark in a clock row in the same group when it is not expected. Then, you can place some \r\nwatchers, that will perform some custom code made by yourself in those cases, such applies a deskew \r\nin image and re-run the scan, for example. \r\nBut, be advised, if you call the scan method again inside the watcher, you should make sure that you \r\nhave a way to leave the watcher to avoid a endless loop. You always can check how many times the watcher \r\ngot raised by checking in `recognizer.raised_watchers[:watcher_name]` hash.\r\n\r\n\r\n### Scan Mark Watcher\r\n\r\n```ruby\r\n# Will execute your custom code if didn't recognizes some mark or recognizes more than one mark in a clock\r\n# row and the same group.  \r\n# It returns the recognizer object, the result of scan hash, a boolean value if this watcher was raised by unmarked\r\n# options and a boolean value if the watcher was raised by a multiple marks options\r\n\r\nrecognizer.add_watcher :scan_mark_watcher do |recognizer, result, unmarked_group_found, multiple_marked_found|\r\n  # place your custom code \r\nend\r\n```\r\n\r\n### Scan Unmarked Watcher\r\n\r\n```ruby\r\n# Will execute your custom code if didn't recognizes some mark.\r\n# It returns the recognizer object, the result of scan hash.\r\n\r\nrecognizer.add_watcher :scan_unmarked_watcher do |recognizer, result|\r\n  # place your custom code \r\nend\r\n```\r\n\r\n### Scan Multiple Marked Watcher\r\n\r\n```ruby\r\n# Will execute your custom code if recognizes more than one mark in a clock row and the same group.\r\n# It returns the recognizer object, the result of scan hash.\r\n\r\nrecognizer.add_watcher :scan_multiple_marked_watcher do |recognizer, result|\r\n  # place your custom code \r\nend\r\n```\r\n\r\n### Incorrect Group Watcher\r\n\r\n```ruby\r\n# Will execute your custom code if didn't a group isn't found, or it have a line count different than expected,\r\n# or in one or more lines the options marks found are different of the specified in marks options.\r\n# It returns the recognizer object, a boolean value to incorrect expected lines count, and a hash with the \r\n# incorrect bubble lines found, and a hash with the coordinates of bubbles adjusted.\r\n# Pay attention on incorrect_expected_lines and incorrect_bubble_line_found, because if some of this variables\r\n# becomes present, then your document may have an incorrect result scan...\r\n\r\nrecognizer.add_watcher :incorrect_group_watcher do |recognizer, incorrect_expected_lines, incorrect_bubble_line_found, bubbles_adjusted|\r\n  # place your custom code \r\nend\r\n```\r\n\r\n### Timed Out Watcher\r\n\r\n```ruby\r\n# Will execute your custom code if your scan outrun the specified timeout in configuration. It returns you recognizer \r\n# object.\r\n\r\nrecognizer.add_watcher :timed_out_watcher do |recognizer|\r\n  # place your custom code \r\nend\r\n```\r\n\r\nContributing\r\n------------\r\n\r\n* Fork it\r\n* Make your implementations\r\n* Send me a pull request\r\n\r\nThank you!\r\n\r\n\r\nLicense\r\n-------\r\n\r\nCopyright © 2012 André Rodrigues, Ronaldo Araújo, Rodrigo Virgilio, Lucas Correa. See MIT-LICENSE for further details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}